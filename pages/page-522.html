<section class="page-section" id="page-522">
    <div class="page-header">
        <div class="page-number">522</div>
        <div class="page-title">
            <h3>Denoising Autoencoders</h3>
            <span>Capitolul 14 - Sectiunea 14.2.2</span>
        </div>
    </div>
    <div class="image-container">
        <img src="book_page_jpg/page-522.jpg"
             alt="Pagina 522" class="page-image" onclick="zoomImage(this)">
    </div>
    <div class="explanation-content">
        <div class="interactive-paragraph">
            <div class="paragraph-main" onclick="toggleParagraph(this)">
                <h4>14.2.2 Denoising Autoencoders</h4>
                <p>In loc sa adaugam o penalizare Î©, putem obtine un autoencoder util schimband <strong>termenul de eroare de reconstructie</strong>. Un autoencoder traditional minimizeaza L(x, g(f(x))). Un <strong>denoising autoencoder</strong> (DAE) minimizeaza: <strong>L(x, g(f(xÌƒ)))</strong>, unde xÌƒ este o copie <strong>corupta</strong> a lui x. DAE trebuie sa invete sa anuleze coruptia, nu doar sa copieze inputul - aceasta forteaza invatarea structurii datelor.</p>
            </div>
            <div class="expandable-sections">
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon simulation">ðŸŽ®</div>
                        <span>Simulare: Denoising AE</span>
                        <span class="arrow">â–¶</span>
                    </div>
                    <div class="section-content">
                        <div class="section-body">
                            <div class="code-block">
import torch
import torch.nn as nn

class DenoisingAutoencoder(nn.Module):
    def __init__(self, input_dim, code_dim, noise_factor=0.3):
        super().__init__()
        self.noise_factor = noise_factor
        self.encoder = nn.Sequential(
            nn.Linear(input_dim, 256),
            nn.ReLU(),
            nn.Linear(256, code_dim)
        )
        self.decoder = nn.Sequential(
            nn.Linear(code_dim, 256),
            nn.ReLU(),
            nn.Linear(256, input_dim),
            nn.Sigmoid()
        )

    def add_noise(self, x):
        # Adauga zgomot Gaussian
        noise = torch.randn_like(x) * self.noise_factor
        return torch.clamp(x + noise, 0, 1)

    def forward(self, x):
        x_noisy = self.add_noise(x)  # xÌƒ = x corupt
        h = self.encoder(x_noisy)    # h = f(xÌƒ)
        r = self.decoder(h)          # r = g(h)
        return r  # Compara cu x ORIGINAL, nu cu xÌƒ!

# Training: loss = L(x, g(f(xÌƒ)))
# Invata sa reconstruiasca x din xÌƒ
                            </div>
                        </div>
                    </div>
                </div>
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon animation">âœ¨</div>
                        <span>Vizualizare: Coruptie</span>
                        <span class="arrow">â–¶</span>
                    </div>
                    <div class="section-content">
                        <div class="section-body">
                            <div style="display: grid; grid-template-columns: 1fr auto 1fr auto 1fr; gap: 10px; align-items: center; text-align: center;">
                                <div style="background: var(--success); padding: 15px; border-radius: 8px;">
                                    <strong>x</strong><br>
                                    <span style="font-size: 0.8rem;">Original curat</span>
                                </div>
                                <div style="font-size: 1.5rem;">â†’</div>
                                <div style="background: var(--warning); padding: 15px; border-radius: 8px;">
                                    <strong>xÌƒ</strong><br>
                                    <span style="font-size: 0.8rem;">Corupt (zgomot)</span>
                                </div>
                                <div style="font-size: 1.5rem;">â†’</div>
                                <div style="background: var(--primary); padding: 15px; border-radius: 8px;">
                                    <strong>r</strong><br>
                                    <span style="font-size: 0.8rem;">Reconstruit</span>
                                </div>
                            </div>
                            <p style="text-align: center; margin-top: 15px; color: var(--text-secondary);">Loss compara r cu x (original), NU cu xÌƒ!</p>
                        </div>
                    </div>
                </div>
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon reference">ðŸ“š</div>
                        <span>Tipuri de Coruptie</span>
                        <span class="arrow">â–¶</span>
                    </div>
                    <div class="section-content">
                        <div class="section-body">
                            <div style="display: grid; gap: 10px;">
                                <div style="background: var(--bg-dark); padding: 12px; border-radius: 8px;">
                                    <strong>Zgomot Gaussian:</strong> xÌƒ = x + N(0, ÏƒÂ²)
                                </div>
                                <div style="background: var(--bg-dark); padding: 12px; border-radius: 8px;">
                                    <strong>Masking (dropout):</strong> Seteaza aleator pixeli la 0
                                </div>
                                <div style="background: var(--bg-dark); padding: 12px; border-radius: 8px;">
                                    <strong>Salt & Pepper:</strong> Pixeli aleatori â†’ 0 sau 1
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="interactive-paragraph">
            <div class="paragraph-main" onclick="toggleParagraph(this)">
                <h4>ReLU pentru Sparsitate Reala</h4>
                <p>O metoda pentru a obtine <strong>zerouri reale</strong> in reprezentare (nu doar valori mici) este folosirea unitatilor <strong>ReLU</strong> in stratul de cod, impreuna cu un prior care impinge valorile spre zero. Cu ReLU si penalizare L1, valorile sunt efectiv zero pentru multi neuroni, nu doar aproape de zero. Aceasta produce reprezentari cu adevarat sparse.</p>
            </div>
        </div>
    </div>
</section>
