<section class="page-section" id="page-522">
    <div class="page-header">
        <div class="page-number">522</div>
        <div class="page-title">
            <h3>Denoising Autoencoders</h3>
            <span>Capitolul 14 - Sectiunea 14.2.2</span>
        </div>
    </div>
    <div class="image-container">
        <img src="book_page_jpg/page-522.jpg"
             alt="Pagina 522" class="page-image" onclick="zoomImage(this)">
    </div>
    <div class="explanation-content">
        <div class="interactive-paragraph">
            <div class="paragraph-main" onclick="toggleParagraph(this)">
                <h4>14.2.2 Denoising Autoencoders</h4>
                <p>In loc sa adaugam o penalizare Î©, putem obtine un autoencoder util schimband <strong>termenul de eroare de reconstructie</strong>. Un autoencoder traditional minimizeaza L(x, g(f(x))). Un <strong>denoising autoencoder</strong> (DAE) minimizeaza: <strong>L(x, g(f(xÌƒ)))</strong>, unde xÌƒ este o copie <strong>corupta</strong> a lui x. DAE trebuie sa invete sa anuleze coruptia, nu doar sa copieze inputul - aceasta forteaza invatarea structurii datelor.</p>
            </div>
            <div class="expandable-sections">
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon simulation">ðŸŽ®</div>
                        <span>Simulare: Denoising AE</span>
                        <span class="arrow">â–¶</span>
                    </div>
                    <div class="section-content">
                        <div class="section-body">
                            <div class="code-block">
import torch
import torch.nn as nn

class DenoisingAutoencoder(nn.Module):
    def __init__(self, input_dim, code_dim, noise_factor=0.3):
        super().__init__()
        self.noise_factor = noise_factor
        self.encoder = nn.Sequential(
            nn.Linear(input_dim, 256),
            nn.ReLU(),
            nn.Linear(256, code_dim)
        )
        self.decoder = nn.Sequential(
            nn.Linear(code_dim, 256),
            nn.ReLU(),
            nn.Linear(256, input_dim),
            nn.Sigmoid()
        )

    def add_noise(self, x):
        # Adauga zgomot Gaussian
        noise = torch.randn_like(x) * self.noise_factor
        return torch.clamp(x + noise, 0, 1)

    def forward(self, x):
        x_noisy = self.add_noise(x)  # xÌƒ = x corupt
        h = self.encoder(x_noisy)    # h = f(xÌƒ)
        r = self.decoder(h)          # r = g(h)
        return r  # Compara cu x ORIGINAL, nu cu xÌƒ!

# Training: loss = L(x, g(f(xÌƒ)))
# Invata sa reconstruiasca x din xÌƒ
                            </div>
                        </div>
                    </div>
                </div>
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon animation">âœ¨</div>
                        <span>Vizualizare: Coruptie</span>
                        <span class="arrow">â–¶</span>
                    </div>
                    <div class="section-content">
                        <div class="section-body">
                            <div style="display: grid; grid-template-columns: 1fr auto 1fr auto 1fr; gap: 10px; align-items: center; text-align: center;">
                                <div style="background: var(--success); padding: 15px; border-radius: 8px;">
                                    <strong>x</strong><br>
                                    <span style="font-size: 0.8rem;">Original curat</span>
                                </div>
                                <div style="font-size: 1.5rem;">â†’</div>
                                <div style="background: var(--warning); padding: 15px; border-radius: 8px;">
                                    <strong>xÌƒ</strong><br>
                                    <span style="font-size: 0.8rem;">Corupt (zgomot)</span>
                                </div>
                                <div style="font-size: 1.5rem;">â†’</div>
                                <div style="background: var(--primary); padding: 15px; border-radius: 8px;">
                                    <strong>r</strong><br>
                                    <span style="font-size: 0.8rem;">Reconstruit</span>
                                </div>
                            </div>
                            <p style="text-align: center; margin-top: 15px; color: var(--text-secondary);">Loss compara r cu x (original), NU cu xÌƒ!</p>
                        </div>
                    </div>
                </div>
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon reference">ðŸ“š</div>
                        <span>Tipuri de Coruptie</span>
                        <span class="arrow">â–¶</span>
                    </div>
                    <div class="section-content">
                        <div class="section-body">
                            <div style="display: grid; gap: 10px;">
                                <div style="background: var(--bg-dark); padding: 12px; border-radius: 8px;">
                                    <strong>Zgomot Gaussian:</strong> xÌƒ = x + N(0, ÏƒÂ²)
                                </div>
                                <div style="background: var(--bg-dark); padding: 12px; border-radius: 8px;">
                                    <strong>Masking (dropout):</strong> Seteaza aleator pixeli la 0
                                </div>
                                <div style="background: var(--bg-dark); padding: 12px; border-radius: 8px;">
                                    <strong>Salt & Pepper:</strong> Pixeli aleatori â†’ 0 sau 1
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="interactive-paragraph">
            <div class="paragraph-main" onclick="toggleParagraph(this)">
                <h4>ReLU pentru Sparsitate Reala</h4>
                <p>O metoda pentru a obtine <strong>zerouri reale</strong> in reprezentare (nu doar valori mici) este folosirea unitatilor <strong>ReLU</strong> in stratul de cod (Glorot et al., 2011b). Cu un prior care impinge valorile spre zero (precum L1), valorile sunt efectiv zero pentru multi neuroni. Aceasta produce reprezentari cu adevarat sparse si controleaza indirect numarul mediu de zerouri.</p>
            </div>
            <div class="expandable-sections">
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon simulation">ðŸŽ®</div>
                        <span>Simulare: ReLU Sparsity</span>
                        <span class="arrow">â–¶</span>
                    </div>
                    <div class="section-content">
                        <div class="section-body">
                            <div class="code-block">
import torch
import torch.nn as nn

class ReLUSparseAutoencoder(nn.Module):
    """
    ReLU + L1 penalty = zerouri EXACTE (nu aproximative)
    """
    def __init__(self, input_dim, code_dim):
        super().__init__()
        self.encoder = nn.Sequential(
            nn.Linear(input_dim, 512),
            nn.ReLU(),
            nn.Linear(512, code_dim),
            nn.ReLU()  # ReLU in codul final!
        )
        self.decoder = nn.Sequential(
            nn.Linear(code_dim, 512),
            nn.ReLU(),
            nn.Linear(512, input_dim)
        )

    def forward(self, x):
        h = self.encoder(x)
        r = self.decoder(h)
        return r, h

# Cu L1 penalty pe h:
# - Multe unitati au activare EXACT 0 (nu 0.0001)
# - Sparsitate "reala", nu aproximativa
# - Eficient computational (skip zerouri)

def count_zeros(h):
    return (h == 0).sum().item() / h.numel()
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="interactive-paragraph">
            <div class="paragraph-main" onclick="toggleParagraph(this)">
                <h4>DAE si Structura Datelor</h4>
                <p>Antrenamentul denoising forteaza f si g sa invete implicit <strong>structura distributiei datelor</strong> p<sub>data</sub>(x). Alain si Bengio (2013, 2013c) au demonstrat ca DAE invata sa estimeze <strong>score-ul</strong> distributiei datelor - directia in care creste cel mai rapid probabilitatea. Aceasta conexiune leaga DAE de score matching si modele generative moderne.</p>
            </div>
            <div class="expandable-sections">
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon reference">ðŸ“š</div>
                        <span>Context: DAE â†’ Diffusion Models</span>
                        <span class="arrow">â–¶</span>
                    </div>
                    <div class="section-content">
                        <div class="section-body">
                            <div class="key-concept">
                                <h5>De la DAE la Stable Diffusion</h5>
                                <p>Ideile din DAE au evoluat in modelele diffusion moderne:</p>
                                <ul style="margin: 10px 0 0 20px; font-size: 0.9rem;">
                                    <li><strong>DAE (2008):</strong> Invata sa curete zgomot â†’ invata structura datelor</li>
                                    <li><strong>Score Matching (2011):</strong> Estimeaza âˆ‡log p(x)</li>
                                    <li><strong>Diffusion (2020+):</strong> Multiplele nivele de zgomot, denoising iterativ</li>
                                    <li><strong>Stable Diffusion:</strong> DAE in spatiul latent al VAE</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>
