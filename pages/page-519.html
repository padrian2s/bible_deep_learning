<section class="page-section" id="page-519">
    <div class="page-header">
        <div class="page-number">519</div>
        <div class="page-title">
            <h3>Autoencodere Regularizate</h3>
            <span>Capitolul 14 - Sectiunea 14.2</span>
        </div>
    </div>
    <div class="image-container">
        <img src="book_page_jpg/page-519.jpg"
             alt="Pagina 519" class="page-image" onclick="zoomImage(this)">
    </div>
    <div class="explanation-content">
        <div class="interactive-paragraph">
            <div class="paragraph-main" onclick="toggleParagraph(this)">
                <h4>14.2 Autoencodere Regularizate</h4>
                <p>Autoencoderele undercomplete cu cod mai mic decat inputul pot invata caracteristici utile. Dar ce se intampla daca codul are dimensiune <strong>egala sau mai mare</strong> decat inputul (<strong>overcomplete</strong>)? In acest caz, un encoder/decoder liniar poate invata sa copieze perfect fara sa invete nimic util. <strong>Autoencoderele regularizate</strong> rezolva aceasta problema adaugand constrangeri suplimentare pe langa copierea inputului.</p>
            </div>
            <div class="expandable-sections">
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon animation">âœ¨</div>
                        <span>Vizualizare: Under vs Over</span>
                        <span class="arrow">â–¶</span>
                    </div>
                    <div class="section-content">
                        <div class="section-body">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                                <div style="background: var(--bg-dark); padding: 20px; border-radius: 8px; text-align: center;">
                                    <h5 style="color: var(--success);">Undercomplete</h5>
                                    <div style="margin: 15px 0;">
                                        <div style="background: var(--primary); height: 60px; width: 80%; margin: 0 auto; border-radius: 4px; display: flex; align-items: center; justify-content: center;">x (784)</div>
                                        <div style="font-size: 1.5rem;">â†“</div>
                                        <div style="background: var(--accent); height: 30px; width: 30%; margin: 0 auto; border-radius: 4px; display: flex; align-items: center; justify-content: center;">h (32)</div>
                                    </div>
                                    <p style="font-size: 0.9rem; color: var(--text-secondary);">Bottleneck forteaza compresie</p>
                                </div>
                                <div style="background: var(--bg-dark); padding: 20px; border-radius: 8px; text-align: center;">
                                    <h5 style="color: var(--warning);">Overcomplete</h5>
                                    <div style="margin: 15px 0;">
                                        <div style="background: var(--primary); height: 40px; width: 50%; margin: 0 auto; border-radius: 4px; display: flex; align-items: center; justify-content: center;">x (784)</div>
                                        <div style="font-size: 1.5rem;">â†“</div>
                                        <div style="background: var(--warning); height: 60px; width: 90%; margin: 0 auto; border-radius: 4px; display: flex; align-items: center; justify-content: center;">h (1000+)</div>
                                    </div>
                                    <p style="font-size: 0.9rem; color: var(--text-secondary);">Necesita regularizare!</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="interactive-paragraph">
            <div class="paragraph-main" onclick="toggleParagraph(this)">
                <h4>Tipuri de Regularizare</h4>
                <p>Autoencoderele regularizate folosesc functii de cost care incurajeaza alte proprietati pe langa copierea inputului: <strong>sparsitatea</strong> reprezentarii, <strong>derivata mica</strong> a reprezentarii, sau <strong>robustetea</strong> la zgomot si inputuri lipsa. Pot fi neliniare si overcomplete, invatand totusi informatii utile daca capacitatea este controlata. Conexiunea cu modelele generative (Helmholtz machine, VAE, GSN) aduce autoencoderele in centrul cercetarii moderne.</p>
            </div>
            <div class="expandable-sections">
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon reference">ðŸ“š</div>
                        <span>Metode de Regularizare</span>
                        <span class="arrow">â–¶</span>
                    </div>
                    <div class="section-content">
                        <div class="section-body">
                            <div style="display: grid; gap: 15px;">
                                <div style="background: linear-gradient(135deg, var(--primary), transparent); padding: 15px; border-radius: 8px;">
                                    <strong>Sparse Autoencoder</strong>
                                    <p style="margin: 5px 0; font-size: 0.9rem;">Penalizare pe activarile codului â†’ majoritatea unitatilor inactive</p>
                                </div>
                                <div style="background: linear-gradient(135deg, var(--secondary), transparent); padding: 15px; border-radius: 8px;">
                                    <strong>Denoising Autoencoder</strong>
                                    <p style="margin: 5px 0; font-size: 0.9rem;">Invata sa reconstruiasca din input corupt</p>
                                </div>
                                <div style="background: linear-gradient(135deg, var(--accent), transparent); padding: 15px; border-radius: 8px;">
                                    <strong>Contractive Autoencoder</strong>
                                    <p style="margin: 5px 0; font-size: 0.9rem;">Penalizare pe derivata encoderului (Jacobian)</p>
                                </div>
                                <div style="background: linear-gradient(135deg, var(--success), transparent); padding: 15px; border-radius: 8px;">
                                    <strong>Variational Autoencoder (VAE)</strong>
                                    <p style="margin: 5px 0; font-size: 0.9rem;">Regularizare probabilistica, cod cu distributie impusa</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon simulation">ðŸŽ®</div>
                        <span>Simulare: Comparatie Regularizari</span>
                        <span class="arrow">â–¶</span>
                    </div>
                    <div class="section-content">
                        <div class="section-body">
                            <div class="code-block">
import torch
import torch.nn as nn

# Diverse tipuri de regularizare pentru autoencodere

def sparse_loss(h, target_sparsity=0.05):
    """L1 sparsity: penalizeaza activari non-zero"""
    return torch.mean(torch.abs(h))

def kl_sparsity(h, target=0.05):
    """KL divergence sparsity (mai smooth)"""
    rho_hat = torch.mean(h, dim=0)  # Activare medie per unitate
    rho = torch.tensor(target)
    kl = rho * torch.log(rho/rho_hat) + (1-rho) * torch.log((1-rho)/(1-rho_hat))
    return torch.sum(kl)

def contractive_loss(model, x, h):
    """Penalizeaza norma Jacobianului encoderului"""
    h.backward(torch.ones_like(h), retain_graph=True)
    jacobian_norm = torch.sum(x.grad ** 2)
    return jacobian_norm

def denoising_corruption(x, noise_factor=0.3):
    """Corupere pentru denoising AE"""
    noise = torch.randn_like(x) * noise_factor
    return x + noise

# Loss total pentru regularized AE:
# L_total = L_reconstruction + lambda * L_regularization
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="interactive-paragraph">
            <div class="paragraph-main" onclick="toggleParagraph(this)">
                <h4>Conexiunea cu Modelele Generative</h4>
                <p>Orice model generativ cu variabile latente si o procedura de inferenta poate fi vazut ca o forma de autoencoder. Doua abordari importante sunt descendentii <strong>Helmholtz machine</strong> (Hinton et al., 1995b), precum VAE, si <strong>generative stochastic networks</strong> (GSN). Aceste modele invata encodari overcomplete utile deoarece sunt antrenate sa aproximeze maximizeze probabilitatea datelor, nu doar sa copieze inputul.</p>
            </div>
            <div class="expandable-sections">
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon animation">âœ¨</div>
                        <span>Helmholtz Machine â†’ VAE</span>
                        <span class="arrow">â–¶</span>
                    </div>
                    <div class="section-content">
                        <div class="section-body">
                            <div style="background: var(--bg-dark); padding: 20px; border-radius: 8px;">
                                <div style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; gap: 20px;">
                                    <div style="text-align: center;">
                                        <div style="background: var(--primary); padding: 15px; border-radius: 8px; margin-bottom: 10px;">
                                            <strong>Recognition Network</strong><br>
                                            <span style="font-size: 0.8rem;">q(h|x) - Encoder</span>
                                        </div>
                                        <div style="font-size: 2rem;">â†‘</div>
                                        <div style="background: var(--accent); padding: 10px 20px; border-radius: 8px;">x (date)</div>
                                    </div>
                                    <div style="font-size: 2rem;">âŸ·</div>
                                    <div style="text-align: center;">
                                        <div style="background: var(--secondary); padding: 15px; border-radius: 8px; margin-bottom: 10px;">
                                            <strong>Generative Network</strong><br>
                                            <span style="font-size: 0.8rem;">p(x|h) - Decoder</span>
                                        </div>
                                        <div style="font-size: 2rem;">â†“</div>
                                        <div style="background: var(--success); padding: 10px 20px; border-radius: 8px;">x' (generat)</div>
                                    </div>
                                </div>
                                <p style="text-align: center; margin-top: 15px; color: var(--text-secondary);">VAE optimizeaza ELBO = reconstructie - KL(q||prior)</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>
