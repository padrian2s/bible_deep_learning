<section class="page-section" id="page-191">
    <div class="page-header">
        <div class="page-number">191</div>
        <div class="page-title">
            <h3>Capitolul 6: Deep Feedforward Networks</h3>
            <span>6.1 XOR: Calculul Pas cu Pas</span>
        </div>
    </div>
    <div class="image-container">
        <img src="book_page_jpg/page-191.jpg"
             alt="Pagina 191" class="page-image" onclick="zoomImage(this)">
    </div>
    <div class="explanation-content">

        <div class="interactive-paragraph">
            <div class="paragraph-main" onclick="toggleParagraph(this)">
                <h4>Procesarea unui Batch de Input-uri</h4>
                <p>Sa parcurgem modul in care modelul proceseaza un batch de inputuri. Fie X matricea de design continand toate cele patru puncte din spatiul binar de input, cu cate un exemplu pe rand. Primul pas este inmultirea matricei de input cu matricea de ponderi a primului strat.</p>
            </div>
            <div class="expandable-sections">
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon simulation">üéÆ</div>
                        <span>Pasul 1: XW (inmultire matriceala)</span>
                        <span class="arrow">‚ñ∂</span>
                    </div>
                    <div class="section-content">
                        <div class="section-body">
                            <div class="code-block">
import numpy as np

# Matricea de input X (4 exemple √ó 2 features)
X = np.array([[0, 0],
              [0, 1],
              [1, 0],
              [1, 1]])

# Matricea de ponderi W (2 input √ó 2 hidden)
W = np.array([[1, 1],
              [1, 1]])

# Pasul 1: XW
XW = X @ W
print("XW =")
print(XW)
# [[0, 0],
#  [1, 1],
#  [1, 1],
#  [2, 2]]

# Observatie: (0,1) si (1,0) produc acelasi rezultat [1,1]
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="interactive-paragraph">
            <div class="paragraph-main" onclick="toggleParagraph(this)">
                <h4>Adaugarea Bias-ului si Aplicarea ReLU</h4>
                <p>Urmatorul pas este adaugarea vectorului de bias c la fiecare rand. Vectorul c = [0, -1] este broadcast la toate cele 4 randuri. Apoi aplicam transformarea liniar rectificata (ReLU) pentru a obtine vectorul de caracteristici ascunse h pentru fiecare exemplu.</p>
            </div>
            <div class="expandable-sections">
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon simulation">üéÆ</div>
                        <span>Pasul 2-3: Adauga c, aplica ReLU</span>
                        <span class="arrow">‚ñ∂</span>
                    </div>
                    <div class="section-content">
                        <div class="section-body">
                            <div class="code-block">
# Bias vector
c = np.array([0, -1])

# Pasul 2: XW + c (broadcasting)
XW_plus_c = XW + c
print("XW + c =")
print(XW_plus_c)
# [[ 0, -1],
#  [ 1,  0],
#  [ 1,  0],
#  [ 2,  1]]

# Pasul 3: ReLU(XW + c) = max(0, XW + c)
H = np.maximum(0, XW_plus_c)
print("\nh = ReLU(XW + c) =")
print(H)
# [[0, 0],   <- pentru input [0,0]
#  [1, 0],   <- pentru input [0,1]
#  [1, 0],   <- pentru input [1,0]
#  [2, 1]]   <- pentru input [1,1]

# Observatii:
# - [0,0] -> [0,0]: ambele valori negative/zero, devin 0
# - [0,1] si [1,0] -> [1,0]: IDENTICE! (colapsate)
# - [1,1] -> [2,1]: valori pozitive, raman neschimbate
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="interactive-paragraph">
            <div class="paragraph-main" onclick="toggleParagraph(this)">
                <h4>Transformarea Spatiului: Cheia Solutiei</h4>
                <p>In acest spatiu, toate exemplele sunt pe o linie cu panta 1. Pe masura ce ne miscam de-a lungul acestei linii, output-ul trebuie sa inceapa la 0, sa creasca la 1, apoi sa scada inapoi la 0. Un model liniar nu poate implementa o astfel de functie. Pentru a finaliza calculul, aplicam transformarea liniar rectificata care schimba relatia dintre exemple.</p>
            </div>
            <div class="expandable-sections">
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon animation">‚ú®</div>
                        <span>Vizualizare: Transformarea Spatiului</span>
                        <span class="arrow">‚ñ∂</span>
                    </div>
                    <div class="section-content">
                        <div class="section-body">
                            <div style="background: var(--bg-lighter); padding: 20px; border-radius: 12px;">
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                                    <div>
                                        <h5 style="color: var(--primary); margin-bottom: 10px;">Inainte de ReLU (XW+c)</h5>
                                        <div style="background: var(--bg-dark); padding: 15px; border-radius: 8px; font-family: monospace;">
                                            <div>[0,0] ‚Üí [ 0, -1]</div>
                                            <div>[0,1] ‚Üí [ 1,  0]</div>
                                            <div>[1,0] ‚Üí [ 1,  0]</div>
                                            <div>[1,1] ‚Üí [ 2,  1]</div>
                                        </div>
                                        <p style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 10px;">Pe o linie cu panta 1, tot nu e separabil!</p>
                                    </div>
                                    <div>
                                        <h5 style="color: var(--success); margin-bottom: 10px;">Dupa ReLU (h)</h5>
                                        <div style="background: var(--bg-dark); padding: 15px; border-radius: 8px; font-family: monospace;">
                                            <div>[0,0] ‚Üí [0, 0] <span style="color: var(--warning);">target: 0</span></div>
                                            <div>[0,1] ‚Üí [1, 0] <span style="color: var(--success);">target: 1</span></div>
                                            <div>[1,0] ‚Üí [1, 0] <span style="color: var(--success);">target: 1</span></div>
                                            <div>[1,1] ‚Üí [2, 1] <span style="color: var(--warning);">target: 0</span></div>
                                        </div>
                                        <p style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 10px;">Acum punctele sunt separabile!</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="interactive-paragraph">
            <div class="paragraph-main" onclick="toggleParagraph(this)">
                <h4>Pasul Final: Clasificarea Liniara</h4>
                <p>Inmultim cu vectorul de ponderi w = [1, -2]·µÄ pentru a obtine output-ul final. Aceasta clasificare liniara in spatiul h produce exact valorile XOR dorite: crescator in h‚ÇÅ (coeficient pozitiv 1) si descrescator in h‚ÇÇ (coeficient negativ -2).</p>
            </div>
            <div class="expandable-sections">
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon simulation">üéÆ</div>
                        <span>Pasul 4: Output final</span>
                        <span class="arrow">‚ñ∂</span>
                    </div>
                    <div class="section-content">
                        <div class="section-body">
                            <div class="code-block">
# Vector de ponderi pentru output
w = np.array([[1], [-2]])
b = 0

# Pasul 4: y = Hw + b
y = H @ w + b
print("y = Hw + b =")
print(y)
# [[0],    <- [0,0]*[1,-2] = 0*1 + 0*(-2) = 0
#  [1],    <- [1,0]*[1,-2] = 1*1 + 0*(-2) = 1
#  [1],    <- [1,0]*[1,-2] = 1*1 + 0*(-2) = 1
#  [0]]    <- [2,1]*[1,-2] = 2*1 + 1*(-2) = 0

# SUCCES! Output-ul corespunde exact XOR:
# XOR([0,0]) = 0 ‚úì
# XOR([0,1]) = 1 ‚úì
# XOR([1,0]) = 1 ‚úì
# XOR([1,1]) = 0 ‚úì

print("\nVerificare finala:")
targets = np.array([0, 1, 1, 0])
print(f"Predictii: {y.flatten()}")
print(f"Targets:   {targets}")
print(f"MSE: {np.mean((y.flatten() - targets)**2)}")  # 0.0
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>
</section>
