<section class="page-section" id="page-456">
    <div class="page-header">
        <div class="page-number">456</div>
        <div class="page-title">
            <h3>Studiu de Caz: Street View (Detalii)</h3>
            <span>Sectiunea 11.6 (continuare)</span>
        </div>
    </div>
    <div class="image-container">
        <img src="../book_page_jpg/page-456.jpg"
             alt="Pagina 456" class="page-image" onclick="zoomImage(this)">
    </div>
    <div class="explanation-content">
        <div class="interactive-paragraph">
            <div class="paragraph-main" onclick="toggleParagraph(this)">
                <h4>Alegerea Metricilor: 98% Accuracy @ 95% Coverage</h4>
                <p>Proiectul de transcriere a inceput cu alegerea metricilor si target-urilor. Hartile sunt utile doar cu <strong>accuracy ridicata</strong>, deci s-a stabilit un target de <strong>98% accuracy</strong> (nivel uman). Pentru a atinge aceasta acuratete, sistemul sacrifica <strong>coverage</strong> - refuzand sa transcrie exemple incerte. Pe masura ce reteaua s-a imbunatatit, threshold-ul de confidence a putut fi redus, crescand coverage pana la depasirea target-ului de <strong>95%</strong>.</p>
            </div>
            <div class="expandable-sections">
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon animation">âœ¨</div>
                        <span>Vizualizare: Target-uri Proiect</span>
                        <span class="arrow">â–¶</span>
                    </div>
                    <div class="section-content">
                        <div class="section-body">
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                                <div style="background: linear-gradient(135deg, #1b4d1b, #1a1a2e); padding: 20px; border-radius: 10px; text-align: center;">
                                    <div style="color: #4caf50; font-size: 0.9em;">TARGET</div>
                                    <div style="color: white; font-size: 2.5em; font-weight: bold;">98%</div>
                                    <div style="color: #4caf50;">Accuracy</div>
                                    <div style="color: #a0a0a0; font-size: 0.85em; margin-top: 10px;">(nivel uman)</div>
                                </div>
                                <div style="background: linear-gradient(135deg, #1b3d4d, #1a1a2e); padding: 20px; border-radius: 10px; text-align: center;">
                                    <div style="color: #03dac6; font-size: 0.9em;">TARGET</div>
                                    <div style="color: white; font-size: 2.5em; font-weight: bold;">95%</div>
                                    <div style="color: #03dac6;">Coverage</div>
                                    <div style="color: #a0a0a0; font-size: 0.85em; margin-top: 10px;">(5% â†’ operatori umani)</div>
                                </div>
                            </div>
                            <div class="key-concept" style="margin-top: 15px;">
                                <strong>Trade-off:</strong> Accuracy fixa la 98%, optimizata Coverage. Pe masura ce modelul s-a imbunatatit, a putut procesa mai multe imagini mentinand acuratetea.
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="interactive-paragraph">
            <div class="paragraph-main" onclick="toggleParagraph(this)">
                <h4>Stabilirea Baseline-ului: CNN cu Multiple Softmax</h4>
                <p>Urmatorul pas a fost stabilirea unui sistem baseline. Pentru task-uri de viziune, aceasta inseamna o <strong>retea convolutionala cu unitati ReLU</strong>. La momentul respectiv, nu era comun ca o CNN sa produca o <strong>secventa de predictii</strong>. Prima implementare: layerul de output continea <em>n</em> clasificatoare softmax independente, fiecare prezicand una din cele <em>n</em> cifre ale numarului.</p>
            </div>
            <div class="expandable-sections">
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon simulation">ðŸŽ®</div>
                        <span>Cod: Arhitectura Output Multi-Digit</span>
                        <span class="arrow">â–¶</span>
                    </div>
                    <div class="section_content">
                        <div class="section-body">
                            <div class="code-block">
import torch
import torch.nn as nn

class StreetViewTranscriber(nn.Module):
    """
    CNN pentru transcrierea numerelor multi-cifra
    Output: n softmax independente (una per pozitie)
    """
    def __init__(self, max_digits=5):
        super().__init__()

        # Backbone CNN (feature extraction)
        self.features = nn.Sequential(
            nn.Conv2d(3, 48, 5, stride=2),
            nn.ReLU(),
            nn.Conv2d(48, 64, 5),
            nn.ReLU(),
            nn.MaxPool2d(2),
            nn.Conv2d(64, 128, 5),
            nn.ReLU(),
            nn.MaxPool2d(2),
            nn.Conv2d(128, 160, 5),
            nn.ReLU(),
            # ... mai multe layere
            nn.Flatten()
        )

        # Output: n clasificatoare independente
        # Fiecare prezice una din 11 clase: 0-9 sau "nimic"
        self.digit_classifiers = nn.ModuleList([
            nn.Linear(1024, 11) for _ in range(max_digits)
        ])

        # Plus un clasificator pentru lungimea numarului
        self.length_classifier = nn.Linear(1024, max_digits + 1)

    def forward(self, x):
        features = self.features(x)

        length_logits = self.length_classifier(features)
        digit_logits = [clf(features) for clf in self.digit_classifiers]

        return length_logits, digit_logits

# Training: cross-entropy pe fiecare softmax separat
# La inferenta: alege cea mai probabila configuratie
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="interactive-paragraph">
            <div class="paragraph-main" onclick="toggleParagraph(this)">
                <h4>Rafinarea Iterativa: Mecanismul de Rejectie</h4>
                <p>Metodologia recomandata este sa rafinezi iterativ baseline-ul, testÃ¢nd daca fiecare schimbare aduce imbunatatiri. Prima schimbare majora: modificarea metricii de coverage pentru a avea o <strong>baza teoretica solida</strong>. Initial, p(y|x) era calculat ad-hoc multiplicand softmax-urile. Aceasta a motivat dezvoltarea unui <strong>layer de output specializat</strong> si a unei cost function care calculeaza corect log-likelihood-ul. Mecanismul de rejectie a functionat mult mai eficient dupa aceasta schimbare.</p>
            </div>
            <div class="expandable-sections">
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon animation">âœ¨</div>
                        <span>Vizualizare: Iteratii de Imbunatatire</span>
                        <span class="arrow">â–¶</span>
                    </div>
                    <div class="section-content">
                        <div class="section-body">
                            <div style="display: grid; grid-template-columns: 1fr; gap: 10px;">
                                <div style="background: linear-gradient(135deg, #4d4d1b, #1a1a2e); padding: 12px; border-radius: 8px; display: flex; align-items: center; gap: 10px;">
                                    <div style="background: #ffd93d; color: #1a1a2e; min-width: 25px; height: 25px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.9em;">1</div>
                                    <div style="flex: 1;">
                                        <div style="color: #ffd93d; font-weight: bold;">Baseline CNN</div>
                                        <div style="color: #a0a0a0; font-size: 0.85em;">Coverage < 90%</div>
                                    </div>
                                </div>
                                <div style="background: linear-gradient(135deg, #1b4d4d, #1a1a2e); padding: 12px; border-radius: 8px; display: flex; align-items: center; gap: 10px;">
                                    <div style="background: #03dac6; color: #1a1a2e; min-width: 25px; height: 25px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.9em;">2</div>
                                    <div style="flex: 1;">
                                        <div style="color: #03dac6; font-weight: bold;">Cost function corect pentru p(y|x)</div>
                                        <div style="color: #a0a0a0; font-size: 0.85em;">Rejectia functioneaza mai bine</div>
                                    </div>
                                </div>
                                <div style="background: linear-gradient(135deg, #4d1b4d, #1a1a2e); padding: 12px; border-radius: 8px; display: flex; align-items: center; gap: 10px;">
                                    <div style="background: #bb86fc; color: #1a1a2e; min-width: 25px; height: 25px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.9em;">3</div>
                                    <div style="flex: 1;">
                                        <div style="color: #bb86fc; font-weight: bold;">Debugging: crop mai larg</div>
                                        <div style="color: #a0a0a0; font-size: 0.85em;">+10% coverage!</div>
                                    </div>
                                </div>
                                <div style="background: linear-gradient(135deg, #1b4d1b, #1a1a2e); padding: 12px; border-radius: 8px; display: flex; align-items: center; gap: 10px;">
                                    <div style="background: #4caf50; color: #1a1a2e; min-width: 25px; height: 25px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.9em;">4</div>
                                    <div style="flex: 1;">
                                        <div style="color: #4caf50; font-weight: bold;">HP tuning final</div>
                                        <div style="color: #a0a0a0; font-size: 0.85em;">98% accuracy @ >95% coverage - SUCCES!</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="interactive-paragraph">
            <div class="paragraph-main" onclick="toggleParagraph(this)">
                <h4>Instrumentare: Train ~= Test Error</h4>
                <p>La un moment dat, coverage era inca sub 90% si nu existau probleme teoretice evidente. Metodologia sugereaza sa <strong>instrumentam</strong> train si test performance pentru a determina daca problema e underfitting sau overfitting. In acest caz, train si test error erau <strong>aproape identice</strong>! Aceasta indica ca problema nu e overfitting. Motivul: existau <strong>zeci de milioane de exemple</strong> etichetate - datesetul era suficient de mare incat gap-ul era aproape zero.</p>
            </div>
            <div class="expandable-sections">
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon reference">ðŸ“š</div>
                        <span>Insight: Dimensiunea Datasetului</span>
                        <span class="arrow">â–¶</span>
                    </div>
                    <div class="section-content">
                        <div class="section-body">
                            <div class="key-concept">
                                <strong>Lectie cheie:</strong> Cu suficient de multe date, gap-ul train-test dispare aproape complet. In acest caz, orice problema de performanta indica fie underfitting (model prea mic), fie probleme cu datele insele (noise, labele gresite, preprocesare).
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>
