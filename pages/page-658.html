<section class="page-section" id="page-658">
    <div class="page-header">
        <div class="page-number">658</div>
        <div class="page-title">
            <h3>Fixed Point Equations</h3>
            <span>Capitolul 19 - Sectiunea 19.4.1 (continuare)</span>
        </div>
    </div>
    <div class="image-container">
        <img src="book_page_jpg/page-658.jpg"
             alt="Pagina 658" class="page-image" onclick="zoomImage(this)">
    </div>
    <div class="explanation-content">
        <div class="interactive-paragraph">
            <div class="paragraph-main" onclick="toggleParagraph(this)">
                <h4>Fixed Point Equations pentru Mean Field</h4>
                <p>In loc de gradient descent, folosim <strong>fixed point iterations</strong> pentru a gasi optimal h_hat. Setam derivata ELBO fata de fiecare h_hat_i la zero si rezolvam. Rezultatul e o ecuatie de update care converge garantat la un optim local al ELBO.</p>
            </div>
            <div class="expandable-sections">
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon simulation">ðŸŽ®</div>
                        <span>Simulare: Fixed Point Iterations</span>
                        <span class="arrow">â–¶</span>
                    </div>
                    <div class="section-content">
                        <div class="section-body">
                            <div class="formula" style="background: var(--bg-dark); padding: 15px; border-radius: 8px;">
                                <p><strong>Conditia de optimalitate:</strong></p>
                                <p style="text-align: center; margin: 15px 0; font-size: 1.1rem;">âˆ‚L/âˆ‚h_hat_i = 0</p>
                                <p><strong>Rezolvand pentru h_hat_i:</strong></p>
                                <p style="text-align: center; margin: 15px 0; font-size: 1rem;">h_hat_i = Ïƒ(b_i + Î²(v - Î£_{jâ‰ i} W_j h_hat_j)^T W_i - Î²/2 ||W_i||Â²)</p>
                                <p style="margin-top: 10px; font-size: 0.9rem; color: var(--text-secondary);">Unde fiecare h_hat_i depinde de toate celelalte h_hat_j!</p>
                            </div>
                            <div class="code-block" style="margin-top: 15px;">
                                <pre style="color: var(--text-secondary); font-size: 0.85rem;">
import torch

class FixedPointMeanField:
    """Mean Field cu Fixed Point Iterations"""

    def __init__(self, n_visible, n_hidden, beta=1.0):
        self.W = torch.randn(n_visible, n_hidden) * 0.1
        self.b = torch.zeros(n_hidden) - 2.0
        self.beta = beta

    def fixed_point_update(self, v, h_hat, update_order="sequential"):
        """Un pas de fixed point update"""
        h_new = h_hat.clone()

        if update_order == "sequential":
            for i in range(h_hat.shape[1]):
                other_contrib = h_new @ self.W.T - h_new[:, i:i+1] * self.W[:, i:i+1].T
                residual = v - other_contrib
                input_term = self.beta * (residual @ self.W[:, i])
                self_penalty = -0.5 * self.beta * (self.W[:, i] ** 2).sum()
                h_new[:, i] = torch.sigmoid(self.b[i] + input_term + self_penalty)

        elif update_order == "parallel":
            other_contrib = h_hat @ self.W.T
            for i in range(h_hat.shape[1]):
                residual = v - other_contrib + h_hat[:, i:i+1] * self.W[:, i:i+1].T
                input_term = self.beta * (residual @ self.W[:, i])
                self_penalty = -0.5 * self.beta * (self.W[:, i] ** 2).sum()
                h_new[:, i] = torch.sigmoid(self.b[i] + input_term + self_penalty)

        return h_new

    def run_inference(self, v, n_iter=30, tol=1e-5):
        """Ruleaza fixed point pana la convergenta"""
        h_hat = torch.sigmoid(self.b).unsqueeze(0).expand(v.shape[0], -1).clone()

        for t in range(n_iter):
            h_old = h_hat.clone()
            h_hat = self.fixed_point_update(v, h_hat)
            change = (h_hat - h_old).abs().max()

            if t % 10 == 0:
                print(f"Iter {t}: max change = {change:.6f}")

            if change < tol:
                print(f"Converged at iteration {t}")
                break

        return h_hat

model = FixedPointMeanField(n_visible=64, n_hidden=100)
v = torch.randn(16, 64)
h_hat = model.run_inference(v, n_iter=50)
print(f"\nFinal sparsity: {(h_hat < 0.1).float().mean():.1%}")
print(f"Mean activation: {h_hat.mean():.3f}")
                                </pre>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon animation">âœ¨</div>
                        <span>Vizualizare: Convergenta</span>
                        <span class="arrow">â–¶</span>
                    </div>
                    <div class="section-content">
                        <div class="section-body">
                            <div style="background: var(--bg-dark); padding: 20px; border-radius: 12px;">
                                <div style="text-align: center; margin-bottom: 20px;">
                                    <div class="formula" style="font-size: 1.1rem;">Algoritmul Fixed Point</div>
                                </div>
                                <div style="display: flex; justify-content: center; align-items: center; gap: 15px; flex-wrap: wrap;">
                                    <div style="text-align: center; padding: 15px; background: var(--primary); border-radius: 50%; width: 70px; height: 70px; display: flex; align-items: center; justify-content: center;">
                                        <div style="font-weight: bold;">Init</div>
                                    </div>
                                    <div style="font-size: 1.5rem;">â†’</div>
                                    <div style="text-align: center; padding: 15px; background: var(--secondary); border-radius: 8px;">
                                        <div style="font-weight: bold;">Update i=1</div>
                                        <p style="font-size: 0.75rem;">h_hat_1 = Ïƒ(...)</p>
                                    </div>
                                    <div style="font-size: 1.5rem;">â†’</div>
                                    <div style="text-align: center; padding: 15px; background: var(--secondary); border-radius: 8px;">
                                        <div style="font-weight: bold;">Update i=2</div>
                                        <p style="font-size: 0.75rem;">h_hat_2 = Ïƒ(...)</p>
                                    </div>
                                    <div style="font-size: 1.5rem;">â†’</div>
                                    <div style="text-align: center; padding: 5px;">...</div>
                                    <div style="font-size: 1.5rem;">â†’</div>
                                    <div style="text-align: center; padding: 15px; background: var(--success); border-radius: 50%; width: 70px; height: 70px; display: flex; align-items: center; justify-content: center;">
                                        <div style="font-weight: bold; font-size: 0.8rem;">Converge</div>
                                    </div>
                                </div>
                            </div>
                            <div class="key-concept" style="margin-top: 15px;">
                                <h5>Garantii de Convergenta:</h5>
                                <ul style="margin-left: 20px;">
                                    <li>ELBO creste monoton la fiecare update (coordinate ascent)</li>
                                    <li>ELBO e bounded above â†’ garanteaza convergenta</li>
                                    <li>Converge la un <strong>local optimum</strong> (nu neaparat global)</li>
                                    <li>Initializarea poate afecta solutia finala</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon reference">ðŸ“š</div>
                        <span>Variante si Optimizari</span>
                        <span class="arrow">â–¶</span>
                    </div>
                    <div class="section-content">
                        <div class="section-body">
                            <div class="reference-list">
                                <div class="reference-item" style="background: var(--bg-dark); padding: 12px; border-radius: 8px; margin-bottom: 10px;">
                                    <strong style="color: var(--primary);">Sequential vs Parallel Updates</strong>
                                    <p style="font-size: 0.85rem; margin-top: 5px;">Sequential: update h_i folosind h_j actualizat. Parallel: toate simultan. Sequential converge mai rapid dar nu e paralelizabil.</p>
                                </div>
                                <div class="reference-item" style="background: var(--bg-dark); padding: 12px; border-radius: 8px; margin-bottom: 10px;">
                                    <strong style="color: var(--secondary);">Damping</strong>
                                    <p style="font-size: 0.85rem; margin-top: 5px;">h_new = Î± * update + (1-Î±) * h_old. Stabilizeaza convergenta pentru Î± &lt; 1.</p>
                                </div>
                                <div class="reference-item" style="background: var(--bg-dark); padding: 12px; border-radius: 8px; margin-bottom: 10px;">
                                    <strong style="color: var(--accent);">Scheduled Updates</strong>
                                    <p style="font-size: 0.85rem; margin-top: 5px;">Actualizeaza unitatile intr-o ordine random sau bazata pe cat de mult se schimba.</p>
                                </div>
                                <div class="reference-item" style="background: var(--bg-dark); padding: 12px; border-radius: 8px;">
                                    <strong style="color: var(--success);">Amortized (VAE style)</strong>
                                    <p style="font-size: 0.85rem; margin-top: 5px;">In loc de iteratii la test time, antrenam un encoder neural q_Ï†(h|v). O singura forward pass!</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>
