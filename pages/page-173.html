<section class="page-section" id="page-173">
    <div class="page-header">
        <div class="page-number">173</div>
        <div class="page-title">
            <h3>Local Kernels si Problema Checkerboard</h3>
            <span>Capitolul 5 - Sectiunea 5.11.2 (continuare)</span>
        </div>
    </div>
    <div class="image-container">
        <img src="../book_page_jpg/page-173.jpg"
             alt="Pagina 173" class="page-image" onclick="zoomImage(this)">
    </div>
    <div class="explanation-content">
        <div class="interactive-paragraph">
            <div class="paragraph-main" onclick="toggleParagraph(this)">
                <h4>Local Kernels si Template Matching</h4>
                <p>In timp ce k-nearest neighbors copiaza output-ul de la exemple de training apropiate, majoritatea <strong>kernel machines</strong> interpoleaza intre outputs-urile din training set. O clasa importanta sunt <strong>local kernels</strong> unde k(u, v) este mare cand u = v si scade pe masura ce u si v se departeaza. Un kernel local poate fi gandit ca o <strong>similarity function</strong> care face template matching - masoara cat de aproape este un exemplu de test x de fiecare exemplu de training x<sup>(i)</sup>. Multa motivatie pentru deep learning vine din studiul limitarilor local template matching (Bengio et al., 2006b).</p>
            </div>
        </div>

        <div class="interactive-paragraph">
            <div class="paragraph-main" onclick="toggleParagraph(this)">
                <h4>Limitarile Decision Trees</h4>
                <p>Decision trees sufera si ele de limitarile invatarii exclusiv smoothness-based deoarece sparg input space-ul in <strong>cate regiuni sunt frunze</strong>. Daca functia target are n frunze care trebuie reprezentate corect, atunci cel putin n exemple de training sunt necesare pentru a fita arborele. Un multiplu de n este necesar pentru a obtine incredere statistica in output-ul prezis.</p>
            </div>
            <div class="expandable-sections">
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon animation">âœ¨</div>
                        <span>Vizualizare: Regiuni si Exemple</span>
                        <span class="arrow">â–¶</span>
                    </div>
                    <div class="section-content">
                        <div class="section-body">
                            <div class="key-concept">
                                <h5>Scaling-ul Algoritmilor Locali</h5>
                                <div class="formula" style="text-align: center; font-size: 1.2rem; margin: 15px 0; padding: 15px; background: var(--bg-dark); border-radius: 8px;">
                                    O(k) regiuni â†’ O(k) exemple necesare
                                </div>
                                <p style="margin-top: 15px;">Pentru a distinge O(k) regiuni in input space:</p>
                                <ul style="margin-top: 10px; font-size: 0.9rem;">
                                    <li>Avem nevoie de O(k) parametri (one per region)</li>
                                    <li>Fiecare exemplu defineste cel mult o regiune</li>
                                    <li><strong>Nearest neighbor:</strong> numarul de regiuni â‰¤ numarul de exemple</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="interactive-paragraph">
            <div class="paragraph-main" onclick="toggleParagraph(this)">
                <h4>Problema Checkerboard</h4>
                <p>Exista vreo cale de a reprezenta o functie complexa care are mult mai multe regiuni decat numarul de exemple de training? Presupunand doar <strong>smoothness</strong>, raspunsul este NU. Imaginati-va ca functia target este un <strong>checkerboard</strong> (tabla de sah). Un checkerboard are multe variatii dar exista o structura simpla sub ele. Ce se intampla cand numarul de exemple e mult mai mic decat numarul de patrate? Bazandu-ne doar pe smoothness prior, putem garanta ca ghicim corect culoarea unui nou punct doar daca e in acelasi patrat cu un exemplu. Nu exista garantie ca pattern-ul checkerboard este extrapolat corect!</p>
            </div>
            <div class="expandable-sections">
                <div class="section-tab">
                    <div class="section-header" onclick="toggleSection(this)">
                        <div class="section-icon simulation">ðŸŽ®</div>
                        <span>Simulare: Checkerboard Problem</span>
                        <span class="arrow">â–¶</span>
                    </div>
                    <div class="section-content">
                        <div class="section-body">
                            <div class="code-block">
import numpy as np
from sklearn.neighbors import KNeighborsClassifier

# Checkerboard: y = (floor(x1) + floor(x2)) % 2
def checkerboard(x1, x2, freq=4):
    return (np.floor(x1 * freq) + np.floor(x2 * freq)).astype(int) % 2

# Generam training data (putine exemple)
np.random.seed(42)
n_train = 20  # Mult mai putin decat 16 patrate!
X_train = np.random.rand(n_train, 2)
y_train = checkerboard(X_train[:, 0], X_train[:, 1])

# k-NN
knn = KNeighborsClassifier(n_neighbors=1)
knn.fit(X_train, y_train)

# Test pe grid dens
xx, yy = np.meshgrid(np.linspace(0, 1, 50), np.linspace(0, 1, 50))
X_test = np.c_[xx.ravel(), yy.ravel()]
y_true = checkerboard(X_test[:, 0], X_test[:, 1])
y_pred = knn.predict(X_test)

acc = (y_pred == y_true).mean()
print(f"Checkerboard cu {n_train} exemple:")
print(f"  k-NN accuracy: {acc:.1%}")
print(f"  Random guess:  50%")
print()
print("=> k-NN nu poate invata STRUCTURA!")
print("   Doar interpoleaza local.")
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>
