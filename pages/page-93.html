        <section class="page-section" id="page-93">
            <div class="page-header">
                <div class="page-number">93</div>
                <div class="page-title">
                    <h3>Figura 3.7: Model Directed</h3>
                    <span>Clici, Factori si Partition Function</span>
                </div>
            </div>
            <div class="image-container">
                <img src="book_page_jpg/page-093.jpg"
                     alt="Pagina 93" class="page-image" onclick="zoomImage(this)">
            </div>
            <div class="explanation-content">

                <div class="interactive-paragraph">
                    <div class="paragraph-main" onclick="toggleParagraph(this)">
                        <h4>Figura 3.7: Model Grafic Directed</h4>
                        <p>Aceasta figura arata un <strong>model directed</strong> peste variabilele a, b, c, d, e. Factorizarea implicata de graf este: p(a, b, c, d, e) = p(a) √ó p(b|a) √ó p(c|a,b) √ó p(d|b) √ó p(e|c). Graful ne permite sa vedem rapid proprietati: a si c interactioneaza direct, dar a si e interactioneaza doar INDIRECT prin c.</p>
                    </div>
                    <div class="expandable-sections">
                        <div class="section-tab">
                            <div class="section-header" onclick="toggleSection(this)">
                                <div class="section-icon animation">‚ú®</div>
                                <span>Vizualizare: Graful Directed</span>
                                <span class="arrow">‚ñ∂</span>
                            </div>
                            <div class="section-content">
                                <div class="section-body">
                                    <div style="display: flex; justify-content: center; margin-bottom: 20px;">
                                        <svg width="200" height="200" viewBox="0 0 200 200">
                                            <!-- Nodes -->
                                            <circle cx="60" cy="30" r="20" fill="var(--accent)" stroke="white" stroke-width="2"/>
                                            <circle cx="140" cy="30" r="20" fill="var(--accent)" stroke="white" stroke-width="2"/>
                                            <circle cx="60" cy="100" r="20" fill="var(--secondary)" stroke="white" stroke-width="2"/>
                                            <circle cx="140" cy="100" r="20" fill="var(--secondary)" stroke="white" stroke-width="2"/>
                                            <circle cx="60" cy="170" r="20" fill="var(--warning)" stroke="white" stroke-width="2"/>
                                            <!-- Labels -->
                                            <text x="60" y="35" fill="white" font-size="14" text-anchor="middle" font-weight="bold">a</text>
                                            <text x="140" y="35" fill="white" font-size="14" text-anchor="middle" font-weight="bold">b</text>
                                            <text x="60" y="105" fill="white" font-size="14" text-anchor="middle" font-weight="bold">c</text>
                                            <text x="140" y="105" fill="white" font-size="14" text-anchor="middle" font-weight="bold">d</text>
                                            <text x="60" y="175" fill="white" font-size="14" text-anchor="middle" font-weight="bold">e</text>
                                            <!-- Arrows -->
                                            <defs>
                                                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                                    <polygon points="0 0, 10 3.5, 0 7" fill="white"/>
                                                </marker>
                                            </defs>
                                            <line x1="75" y1="45" x2="125" y2="25" stroke="white" stroke-width="2" marker-end="url(#arrowhead)"/>
                                            <line x1="60" y1="50" x2="60" y2="78" stroke="white" stroke-width="2" marker-end="url(#arrowhead)"/>
                                            <line x1="125" y1="45" x2="75" y2="85" stroke="white" stroke-width="2" marker-end="url(#arrowhead)"/>
                                            <line x1="140" y1="50" x2="140" y2="78" stroke="white" stroke-width="2" marker-end="url(#arrowhead)"/>
                                            <line x1="60" y1="120" x2="60" y2="148" stroke="white" stroke-width="2" marker-end="url(#arrowhead)"/>
                                        </svg>
                                    </div>
                                    <div class="formula" style="text-align: center; padding: 15px; background: var(--bg-lighter); border-radius: 8px;">
                                        p(a,b,c,d,e) = p(a) ¬∑ p(b|a) ¬∑ p(c|a,b) ¬∑ p(d|b) ¬∑ p(e|c)
                                    </div>
                                    <p style="margin-top: 15px; font-size: 0.85rem; color: var(--text-secondary); text-align: center;">
                                        Fiecare nod depinde doar de parintii sai (nodurile cu sageti spre el)
                                    </p>
                                </div>
                            </div>
                        </div>
                        <div class="section-tab">
                            <div class="section-header" onclick="toggleSection(this)">
                                <div class="section-icon simulation">üéÆ</div>
                                <span>Cod: Sampling din model directed</span>
                                <span class="arrow">‚ñ∂</span>
                            </div>
                            <div class="section-content">
                                <div class="section-body">
                                    <div class="code-block">
import numpy as np

# Model directed: a -> b, {a,b} -> c, b -> d, c -> e
# Sampling "ancestral" - in ordine topologica

def sample_directed_model():
    # P(a) - prior
    a = np.random.choice([0, 1], p=[0.6, 0.4])

    # P(b | a)
    p_b = 0.7 if a == 1 else 0.3
    b = np.random.choice([0, 1], p=[1-p_b, p_b])

    # P(c | a, b)
    if a == 1 and b == 1:
        p_c = 0.9
    elif a == 1 or b == 1:
        p_c = 0.5
    else:
        p_c = 0.1
    c = np.random.choice([0, 1], p=[1-p_c, p_c])

    # P(d | b)
    p_d = 0.8 if b == 1 else 0.2
    d = np.random.choice([0, 1], p=[1-p_d, p_d])

    # P(e | c)
    p_e = 0.85 if c == 1 else 0.15
    e = np.random.choice([0, 1], p=[1-p_e, p_e])

    return {'a': a, 'b': b, 'c': c, 'd': d, 'e': e}

# Generam esantioane
samples = [sample_directed_model() for _ in range(10000)]

# Verificam independente conditionate
# a si e sunt independente conditionate de c?
def check_conditional_independence(samples):
    # P(e=1 | c=1, a=0) vs P(e=1 | c=1, a=1)
    e_given_c1_a0 = [s['e'] for s in samples if s['c']==1 and s['a']==0]
    e_given_c1_a1 = [s['e'] for s in samples if s['c']==1 and s['a']==1]

    print(f"P(e=1 | c=1, a=0) = {np.mean(e_given_c1_a0):.3f}")
    print(f"P(e=1 | c=1, a=1) = {np.mean(e_given_c1_a1):.3f}")
    print("(ar trebui sa fie ~egale daca a ‚ä• e | c)")

check_conditional_independence(samples)
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="interactive-paragraph">
                    <div class="paragraph-main" onclick="toggleParagraph(this)">
                        <h4>Clici in Modelele Undirected</h4>
                        <p>In modelele <strong>undirected</strong>, factorii sunt asociati cu <strong>clici</strong> - seturi de noduri in care fiecare pereche e conectata direct. Fiecare clica C are un factor œà(C). Important: acesti factori NU sunt probabilitati! Sunt doar functii <strong>non-negative</strong>. Nu trebuie sa sumeze la 1. De aceea avem nevoie de normalizare.</p>
                    </div>
                    <div class="expandable-sections">
                        <div class="section-tab">
                            <div class="section-header" onclick="toggleSection(this)">
                                <div class="section-icon animation">‚ú®</div>
                                <span>Vizualizare: Clici</span>
                                <span class="arrow">‚ñ∂</span>
                            </div>
                            <div class="section-content">
                                <div class="section-body">
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                                        <div style="background: var(--bg-lighter); padding: 15px; border-radius: 8px; text-align: center;">
                                            <strong style="color: var(--accent);">Clica = Subgraf Complet</strong>
                                            <div style="margin: 15px 0;">
                                                <svg width="100" height="80" viewBox="0 0 100 80">
                                                    <polygon points="50,10 20,70 80,70" fill="none" stroke="var(--accent)" stroke-width="3"/>
                                                    <circle cx="50" cy="10" r="8" fill="var(--accent)"/>
                                                    <circle cx="20" cy="70" r="8" fill="var(--accent)"/>
                                                    <circle cx="80" cy="70" r="8" fill="var(--accent)"/>
                                                </svg>
                                            </div>
                                            <p style="font-size: 0.8rem; color: var(--text-secondary);">Toate nodurile sunt conectate intre ele</p>
                                        </div>
                                        <div style="background: var(--bg-lighter); padding: 15px; border-radius: 8px; text-align: center;">
                                            <strong style="color: var(--warning);">Factor pe Clica</strong>
                                            <div class="formula" style="margin: 15px 0; font-size: 0.9rem;">
                                                œà_C(x_C) ‚â• 0
                                            </div>
                                            <p style="font-size: 0.8rem; color: var(--text-secondary);">NU e probabilitate!</p>
                                            <p style="font-size: 0.8rem; color: var(--text-secondary);">Nu trebuie sa sumeze la 1</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="interactive-paragraph">
                    <div class="paragraph-main" onclick="toggleParagraph(this)">
                        <h4>Partition Function Z</h4>
                        <p>Deoarece factorii œà nu sunt normalizati, produsul lor nu va suma la 1. Trebuie sa impartim la o constanta de normalizare <strong>Z</strong> (partition function): p(<strong>x</strong>) = (1/Z) ‚àè·µ¢ œà‚ÅΩ‚Å±‚Åæ(C‚ÅΩ‚Å±‚Åæ). Z este suma/integrala peste TOATE configuratiile posibile. Pentru multe variabile, calculul lui Z este <strong>intractabil</strong> - una din marile provocari ale modelelor undirected!</p>
                    </div>
                    <div class="expandable-sections">
                        <div class="section-tab">
                            <div class="section-header" onclick="toggleSection(this)">
                                <div class="section-icon animation">‚ú®</div>
                                <span>Vizualizare: Partition Function</span>
                                <span class="arrow">‚ñ∂</span>
                            </div>
                            <div class="section-content">
                                <div class="section-body">
                                    <div class="formula" style="text-align: center; padding: 20px; background: var(--bg-lighter); border-radius: 8px; margin-bottom: 15px;">
                                        <div style="font-size: 1.1rem;">p(<strong>x</strong>) = (1/Z) ‚àè·µ¢ œà‚ÅΩ‚Å±‚Åæ(C‚ÅΩ‚Å±‚Åæ)</div>
                                        <div style="margin-top: 15px; font-size: 0.9rem; color: var(--text-secondary);">
                                            Z = Œ£_x ‚àè·µ¢ œà‚ÅΩ‚Å±‚Åæ(C‚ÅΩ‚Å±‚Åæ)
                                        </div>
                                    </div>
                                    <div class="key-concept">
                                        <strong>De ce Z e problematic:</strong>
                                        <ul style="margin-top: 10px; color: var(--text-secondary);">
                                            <li>Pentru n variabile binare: 2‚Åø termeni de sumat!</li>
                                            <li>n = 100 ‚Üí ~10¬≥‚Å∞ termeni (imposibil)</li>
                                            <li>Solutii: MCMC, variational methods, approximate inference</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="section-tab">
                            <div class="section-header" onclick="toggleSection(this)">
                                <div class="section-icon simulation">üéÆ</div>
                                <span>Cod: Calculul lui Z (exemplu mic)</span>
                                <span class="arrow">‚ñ∂</span>
                            </div>
                            <div class="section-content">
                                <div class="section-body">
                                    <div class="code-block">
import numpy as np
from itertools import product

# Model undirected simplu: 3 variabile binare
# Clici: {A, B}, {B, C}

def psi_ab(a, b):
    """Factor pentru clica {A, B}"""
    # Preferam ca A si B sa fie egale
    return 2.0 if a == b else 0.5

def psi_bc(b, c):
    """Factor pentru clica {B, C}"""
    # Preferam ca B si C sa fie diferite
    return 0.3 if b == c else 1.5

# Calculam Z prin enumerare (posibil doar pt variabile putine!)
Z = 0
unnormalized = {}

for a, b, c in product([0, 1], repeat=3):
    val = psi_ab(a, b) * psi_bc(b, c)
    unnormalized[(a, b, c)] = val
    Z += val

print(f"Partition function Z = {Z:.4f}")
print("\nDistributia normalizata:")
for (a, b, c), val in unnormalized.items():
    prob = val / Z
    print(f"P(a={a}, b={b}, c={c}) = {prob:.4f}")

# Verificare: suma = 1
print(f"\nSuma probabilitatilor: {sum(v/Z for v in unnormalized.values()):.4f}")
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="section-tab">
                            <div class="section-header" onclick="toggleSection(this)">
                                <div class="section-icon reference">üìö</div>
                                <span>Modele care folosesc Z</span>
                                <span class="arrow">‚ñ∂</span>
                            </div>
                            <div class="section-content">
                                <div class="section-body">
                                    <ul class="reference-list">
                                        <li class="reference-item">
                                            <span>üî≤</span>
                                            <div><strong>Restricted Boltzmann Machines (RBM)</strong> - Z intractabil, antrenare cu Contrastive Divergence</div>
                                        </li>
                                        <li class="reference-item">
                                            <span>üè∑Ô∏è</span>
                                            <div><strong>Conditional Random Fields (CRF)</strong> - Z calculabil pentru secvente (algoritm forward-backward)</div>
                                        </li>
                                        <li class="reference-item">
                                            <span>‚ö°</span>
                                            <div><strong>Energy-Based Models</strong> - œà(x) = exp(-E(x)), Z = ‚à´ exp(-E(x)) dx</div>
                                        </li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </section>
